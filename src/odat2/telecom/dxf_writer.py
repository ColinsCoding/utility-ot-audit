from __future__ import annotations

from dataclasses import dataclass
from typing import Iterable, List, Tuple, Optional
import datetime


PointF = Tuple[float, float]


@dataclass
class DXFPolyline:
    layer: str
    points: List[PointF]
    closed: bool = False
    color: Optional[int] = None  # 1-255, None = BYLAYER


def _dxf_pair(code: int, value) -> str:
    return f"{code}\n{value}\n"


def write_r12_dxf_polylines(polylines: Iterable[DXFPolyline], out_path: str, *, units: str = "unit") -> None:
    """
    Write a minimal AutoCAD R12 ASCII DXF containing LWPOLYLINE entities.

    This avoids external dependencies (ezdxf) and is sufficient for:
    - importing into AutoCAD / DraftSight / LibreCAD
    - layer-based separation by cable type / route id

    Note: R12 technically predates LWPOLYLINE; many tools still accept it.
    If you need strict R12 compatibility, swap to POLYLINE/VERTEX/SEQEND.
    """
    now = datetime.datetime.now(datetime.UTC).strftime("%Y-%m-%dT%H:%M:%SZ")

    parts: List[str] = []
    parts.append("0\nSECTION\n2\nHEADER\n")
    parts.append(_dxf_pair(9, "$ACADVER") + _dxf_pair(1, "AC1009"))  # R12
    parts.append(_dxf_pair(9, "$COMMENT") + _dxf_pair(1, f"Generated by odat2 route-optimize at {now}"))
    parts.append("0\nENDSEC\n")

    # Minimal tables section with layers
    layer_names = sorted({p.layer for p in polylines})
    parts.append("0\nSECTION\n2\nTABLES\n")
    parts.append("0\nTABLE\n2\nLAYER\n70\n{}\n".format(len(layer_names)))
    for name in layer_names:
        parts.append("0\nLAYER\n2\n{}\n70\n0\n62\n7\n6\nCONTINUOUS\n".format(name))
    parts.append("0\nENDTAB\n0\nENDSEC\n")

    # Entities
    parts.append("0\nSECTION\n2\nENTITIES\n")
    for pl in polylines:
        if not pl.points:
            continue
        parts.append("0\nLWPOLYLINE\n")
        parts.append(_dxf_pair(8, pl.layer))
        if pl.color is not None:
            parts.append(_dxf_pair(62, int(pl.color)))
        parts.append(_dxf_pair(90, len(pl.points)))
        parts.append(_dxf_pair(70, 1 if pl.closed else 0))
        for (x, y) in pl.points:
            parts.append(_dxf_pair(10, float(x)))
            parts.append(_dxf_pair(20, float(y)))
    parts.append("0\nENDSEC\n0\nEOF\n")

    with open(out_path, "w", encoding="utf-8", newline="\n") as f:
        f.write("".join(parts))
